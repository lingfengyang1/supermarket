module.exports = {
  plugins: {
    autoprefixer: {},
    // 现在的vue项目并不会灵活的适配不同的设备分辨率 而是显示固定的宽高 因此我们需要通过postcss-px-to-viewport插件来针对不同的设备进行相同组件宽高的调整
    // 使用过程：1.安装 2.配置
    "postcss-px-to-viewport": {
      // 视口的宽高一般配置为iphone6的宽高 即750px x 1334px 但是由于设备的宽高是一个点对应2px 所以说 我们需要根据设备的宽高像素得到真实的宽高
      // 适配的原理在于首先我们会根据iphone6的视口宽高将px转换为vw(1vw相当于1% * 视口宽度) 此时的组件宽高就是一个动态值(相对于视口宽度计算) 当我们的设备分辨率调整以后 会根据调整前后设备的视口宽度得到一个比例 然后根据该比例计算处调整以后的具体vw值 即组件vw2 = (视口宽度2 / 视口宽度1) *  组件vw1
      viewportWidth: 375,  // 视窗的宽度，对应的是我们设计稿的宽度.
      viewportHeight: 667, // 视窗的高度，对应的是我们设计稿的高度.(也可以不配置)
      unitPrecision: 5, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）
      viewportUnit: 'vw', // 指定需要转换成的视窗单位，建议使用vw
      // 该属性必须是数组类型 并且元素可以是字符串(字符串用于匹配指定的选择器 而没办法匹配指定选择器内部的子元素 即无法忽略指定选择器内部子元素的px转换) 也可以是正则表达式(以//包裹)
      // 如果你不想要内置过多的类对这些类进行px转换忽略的话 那么你可以为这些类统统指定相同的类名 然后在此导入即可避免导入过多的类
      // 以下属性是会对指定选择器(包括选择器元素内部的子元素以及slot元素的替换内容)都进行px转换的忽略
      selectorBlackList: ['ignore', 'tab-bar', 'tab-bar-item'], // 指定不需要转换的类,后面再讲.
      // 该属性就表示px转换的下限
      minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位.
      mediaQuery: false, // 允许在媒体查询中转换`px`
      // 该属性和selectorBlackList不同的地方在于他取值可以是数组 也可以直接是正则表达式 并且他是对某个文件进行px转换的忽略
      // 但是注意 如果你的文件中包含slot元素 由于slot元素替换的内容在另外一个文件 所以该slot元素的替换内容并不会忽略px的转换
      // 在js的正则表达式中 正则表达式是通过//包裹的 /^abc/表示匹配以abc开头的字符串 而/abc$/则表示匹配以abc结尾的字符串 而/abc/则表示匹配包含abc的字符串 以下正则表达式可以忽略tabbar/tabtaritem/maintabbar这三个文件的px转换操作
      // exclude: [/TabBar/] // 必须是正则，匹配文件的
    },
  }

}
